fun main(args: Array<String>) {
    println(labelMultiply(3, 4, "The result is: ")) -> Prints "The result is: 12
}
can also be written in different order
This is also called "Named Arguments"
fun main(args: Array<String>) {
    println(labelMultiply(operand2 =3, label ="The result is: ", operand1 = 4)) -> Prints "The result is: 12
}

fun labelMultiply(operand1: Int, operand2: Int, label: String) : String {
    return ("$label $(operand1+operand2))
}
This can be also written as:

fun labelMultiply(operand1: Int, operand2: Int, label: String) : String = "$label $(operand1 + operand2)" 

--------------------------------------------------------------------------------

fun main (args: String<Array>) {
    val emp = Employee("Jane")
    println(emp.upperCaseFirstName) -> Prints Jane
}

class Employee(val firstName: String){
    fun upperCaseFirstName() = firstName.toUpperCase()
}

-------------------------------------------------------------------------------

fun main(args: Array<String>){

    val car1: Car("blue","Toyota", 2015)
    val car2: Car("green","Ford", 2016)
    val car3: Car("red","Chevy", 2017)

    printColors(car1,car2,car3, str = "Color:")
}

For passing array to the function which only takes we use:
    val manyCars = arrayOf(car1,car2,car3)
    printColors(*manyCars) -> * is called spread operator



fun printColors(vararg cars: Car, str: String){ -> Can only have only one vararg
    for (car in cars) {
        println(car.color)
    }
}

data class Car(val color: String, val model: String, val year: Int){

}

-----------------------------------------------------------------------------

Add String. to create extention function
You can use this instead of  .str

-----------------------------------------------------------------------------

Inline: When an inline function is compiled its body is directly substituted for the function call in other words it's not compiled to a function at all it's compiled to its body.

Add inline: Works best with Lambda Parameters

inline fun labelMultiply(operand1)
-----------------------------------------------------------------------------

Inheritance:
Everthing in Kotlin is public and final by default.

open class Printer { -> Open keyword tells compiler that we want classes to be able to extend it

}

class LaserPrinter: Printer {
    constructor(): super() -> If we didn't want primary constructor
}

or we can:

open class Printer() {

}

class LaserPrinter(): Printer() {

}

and we can type like this:

fun main(args: Array<String>) {
    val laserPrinter = LaserPrinter("Brother 6969")
    laserPrinter.printModel()
}

abstract class Printer(val modelName: String){

    open fun printModel() = println("The model name of this printer is $modelName) -> when you want function to be extendable or to be able to be overridden you have to use the open keyword unless its abstract.

    abstract fun bestSellingPrice(): Double -> abstract functions are open by default
}
 -> No need of open keyword because abstract is present.

class LaserPrinter(modelName: String: Printer(modelName)){
    override fun printModel() = println("The model name of this laser printter is $modelName) -> Need override keyword to override a function

    override fun bestSellingPrice(): Double = 129.99 -> Always have to use override

